"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var Log = _interopRequireWildcard(require("../util/logging.js"));
var _inflator = _interopRequireDefault(require("../inflator.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var UDPDecoder = /*#__PURE__*/function () {
  function UDPDecoder() {
    _classCallCheck(this, UDPDecoder);
    this._filter = null;
    this._palette = new Uint8Array(1024); // 256 * 4 (max palette size * max bytes-per-pixel)
    this._directDraw = false; //Draw directly to the canvas without ordering

    this._zlibs = [];
    for (var i = 0; i < 4; i++) {
      this._zlibs[i] = new _inflator["default"]();
    }
  }
  _createClass(UDPDecoder, [{
    key: "decodeRect",
    value: function decodeRect(x, y, width, height, data, display, depth, frame_id) {
      var ctl = data[12];
      ctl = ctl >> 4;
      var ret;
      if (ctl === 0x08) {
        ret = this._fillRect(x, y, width, height, data, display, depth, frame_id);
      } else if (ctl === 0x09) {
        ret = this._jpegRect(x, y, width, height, data, display, depth, frame_id);
      } else if (ctl === 0x0A) {
        ret = this._pngRect(x, y, width, height, data, display, depth, frame_id);
      } else if ((ctl & 0x08) == 0) {
        ret = this._basicRect(ctl, x, y, width, height, data, display, depth, frame_id);
      } else if (ctl === 0x0B) {
        ret = this._webpRect(x, y, width, height, data, display, depth, frame_id);
      } else {
        throw new Error("Illegal udp compression received (ctl: " + ctl + ")");
      }
      return ret;
    }
  }, {
    key: "_fillRect",
    value: function _fillRect(x, y, width, height, data, display, depth, frame_id) {
      display.fillRect(x, y, width, height, [data[13], data[14], data[15]], frame_id, this._directDraw);
      return true;
    }
  }, {
    key: "_jpegRect",
    value: function _jpegRect(x, y, width, height, data, display, depth, frame_id) {
      var img = this._readData(data);
      if (img === null) {
        return false;
      }
      display.imageRect(x, y, width, height, "image/jpeg", img, frame_id, this._directDraw);
      return true;
    }
  }, {
    key: "_webpRect",
    value: function _webpRect(x, y, width, height, data, display, depth, frame_id) {
      var img = this._readData(data);
      if (img === null) {
        return false;
      }
      display.imageRect(x, y, width, height, "image/webp", img, frame_id, this._directDraw);
      return true;
    }
  }, {
    key: "_pngRect",
    value: function _pngRect(x, y, width, height, data, display, depth, frame_id) {
      //throw new Error("PNG received in UDP rect");
      Log.Error("PNG received in UDP rect");
    }
  }, {
    key: "_basicRect",
    value: function _basicRect(ctl, x, y, width, height, data, display, depth, frame_id) {
      var zlibs_flags = data[12];
      // Reset streams if the server requests it
      for (var i = 0; i < 4; i++) {
        if (zlibs_flags >> i & 1) {
          this._zlibs[i].reset();
          //Log.Debug("Reset zlib stream " + i);
        }
      }

      var filter = data[13];
      var data_index = 14;
      var streamId = ctl & 0x3;
      if (!(ctl & 0x4)) {
        // Implicit CopyFilter
        filter = 0;
        data_index = 13;
      }
      var ret;
      switch (filter) {
        case 0:
          // CopyFilter
          ret = this._copyFilter(streamId, x, y, width, height, data, display, depth, frame_id, data_index);
          break;
        case 1:
          // PaletteFilter
          ret = this._paletteFilter(streamId, x, y, width, height, data, display, depth, frame_id);
          break;
        case 2:
          // GradientFilter
          ret = this._gradientFilter(streamId, x, y, width, height, data, display, depth, frame_id);
          break;
        default:
          throw new Error("Illegal tight filter received (ctl: " + this._filter + ")");
      }
      return ret;
    }
  }, {
    key: "_copyFilter",
    value: function _copyFilter(streamId, x, y, width, height, data, display, depth, frame_id) {
      var data_index = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 14;
      var uncompressedSize = width * height * 3;
      if (uncompressedSize === 0) {
        return true;
      }
      if (uncompressedSize < 12) {
        data = data.slice(data_index, data_index + uncompressedSize);
      } else {
        data = this._readData(data, data_index);
        if (data === null) {
          return false;
        }
        this._zlibs[streamId].setInput(data);
        data = this._zlibs[streamId].inflate(uncompressedSize);
        this._zlibs[streamId].setInput(null);
      }
      var rgbx = new Uint8Array(width * height * 4);
      for (var i = 0, j = 0; i < width * height * 4; i += 4, j += 3) {
        rgbx[i] = data[j];
        rgbx[i + 1] = data[j + 1];
        rgbx[i + 2] = data[j + 2];
        rgbx[i + 3] = 255; // Alpha
      }

      display.blitImage(x, y, width, height, rgbx, 0, frame_id, this._directDraw);
      return true;
    }
  }, {
    key: "_paletteFilter",
    value: function _paletteFilter(streamId, x, y, width, height, data, display, depth, frame_id) {
      var numColors = data[14] + 1;
      var paletteSize = numColors * 3;
      var palette = data.slice(15, 15 + paletteSize);
      var bpp = numColors <= 2 ? 1 : 8;
      var rowSize = Math.floor((width * bpp + 7) / 8);
      var uncompressedSize = rowSize * height;
      var data_i = 15 + paletteSize;
      if (uncompressedSize === 0) {
        return true;
      }
      if (uncompressedSize < 12) {
        data = data.slice(data_i, data_i + uncompressedSize);
      } else {
        data = this._readData(data, data_i);
        if (data === null) {
          return false;
        }
        this._zlibs[streamId].setInput(data);
        data = this._zlibs[streamId].inflate(uncompressedSize);
        this._zlibs[streamId].setInput(null);
      }

      // Convert indexed (palette based) image data to RGB
      if (numColors == 2) {
        this._monoRect(x, y, width, height, data, palette, display, frame_id);
      } else {
        this._paletteRect(x, y, width, height, data, palette, display, frame_id);
      }
      return true;
    }
  }, {
    key: "_monoRect",
    value: function _monoRect(x, y, width, height, data, palette, display, frame_id) {
      // Convert indexed (palette based) image data to RGB
      // TODO: reduce number of calculations inside loop
      var dest = this._getScratchBuffer(width * height * 4);
      var w = Math.floor((width + 7) / 8);
      var w1 = Math.floor(width / 8);
      for (var _y = 0; _y < height; _y++) {
        var dp = void 0,
          sp = void 0,
          _x = void 0;
        for (_x = 0; _x < w1; _x++) {
          for (var b = 7; b >= 0; b--) {
            dp = (_y * width + _x * 8 + 7 - b) * 4;
            sp = (data[_y * w + _x] >> b & 1) * 3;
            dest[dp] = palette[sp];
            dest[dp + 1] = palette[sp + 1];
            dest[dp + 2] = palette[sp + 2];
            dest[dp + 3] = 255;
          }
        }
        for (var _b = 7; _b >= 8 - width % 8; _b--) {
          dp = (_y * width + _x * 8 + 7 - _b) * 4;
          sp = (data[_y * w + _x] >> _b & 1) * 3;
          dest[dp] = palette[sp];
          dest[dp + 1] = palette[sp + 1];
          dest[dp + 2] = palette[sp + 2];
          dest[dp + 3] = 255;
        }
      }
      display.blitImage(x, y, width, height, dest, 0, frame_id, this._directDraw);
    }
  }, {
    key: "_paletteRect",
    value: function _paletteRect(x, y, width, height, data, palette, display, frame_id) {
      // Convert indexed (palette based) image data to RGB
      var dest = this._getScratchBuffer(width * height * 4);
      var total = width * height * 4;
      for (var i = 0, j = 0; i < total; i += 4, j++) {
        var sp = data[j] * 3;
        dest[i] = palette[sp];
        dest[i + 1] = palette[sp + 1];
        dest[i + 2] = palette[sp + 2];
        dest[i + 3] = 255;
      }
      display.blitImage(x, y, width, height, dest, 0, frame_id, this._directDraw);
    }
  }, {
    key: "_gradientFilter",
    value: function _gradientFilter(streamId, x, y, width, height, data, display, depth, frame_id) {
      throw new Error("Gradient filter not implemented");
    }
  }, {
    key: "_readData",
    value: function _readData(data) {
      var len_index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 13;
      if (data.length < len_index + 2) {
        Log.Error("UDP Decoder, readData, invalid data len");
        return null;
      }
      var i = len_index;
      var _byte = data[i++];
      var len = _byte & 0x7f;
      // lenth field is variably sized 1 to 3 bytes long
      if (_byte & 0x80) {
        _byte = data[i++];
        len |= (_byte & 0x7f) << 7;
        if (_byte & 0x80) {
          _byte = data[i++];
          len |= _byte << 14;
        }
      }

      //TODO: get rid of me
      if (data.length !== len + i) {
        console.log('Rect of size ' + len + ' with data size ' + data.length + ' index of ' + i);
      }
      return data.slice(i);
    }
  }, {
    key: "_getScratchBuffer",
    value: function _getScratchBuffer(size) {
      if (!this._scratchBuffer || this._scratchBuffer.length < size) {
        this._scratchBuffer = new Uint8Array(size);
      }
      return this._scratchBuffer;
    }
  }]);
  return UDPDecoder;
}();
exports["default"] = UDPDecoder;